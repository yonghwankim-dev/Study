
## 2.1 쿠버네티스란?
쿠버네티스(Kubernetes, k8s)는 **여러대의 서버에서 실행**되는 컨테이너들을 하나의 클러스터로 묶어서 컨테이너의 배포, 확장, 로드 밸런싱, 장애 복구 등을 자동화하는 컨테이너 오케스트레이션(Orchestration) 플랫폼입니다. 하나의 호스트 운영체제에서 실행되는 여러 개의 컨테이너는 호스트 운영체제의 커널을 공유하며 실행됩니다. 이 때문에 컨테이너는 가상 머신보다 훨씬 가볍지만, 컨테이너는 가상 머신과 마찬가지로 실행 환경을 독립적으로 운영할 수 있습니다. 컨테이너는 가벼우면서도 가상화된 실행 환경을 가지기 때문에, 쉽게 복제하거나 배포할 수 있습니다. 이러한 여러 서버에 배포된 컨테이너들을 관리하는 기술을 **컨테이너 오케스트레이션**이라고 합니다. 쿠버네티스를 이용해서 **컨테이너의 배포, 확장, 스케줄링을 자동화** 할 수 있습니다.

#### 쿠버네티스 역사
- 쿠버네티스는 그리스어로 키잡이(helmsman)를 의미
- 2014년 구글에서 처음 발표, 2015년 쿠버네티스 v1.0 출시
- 쿠버네티스는 출시하자마자 CNCF(Cloud Native Computing Foundation)  재단에 기증

### 2.1.1 컨테이너 오케스트레이션이란?
컨테이너 오케스트레이션은 여러 서버에서 배포되는 컨테이너들을 배포, 확장, 로드 밸런싱, 장애 복구 등을 자동화하는 플랫폼입니다. 쿠버네티스는 대표적인 컨테이너 오케스트레이션 플랫폼입니다.

**쿠버네티스 역할**
- 실행 및 배포
- 이중화 및 가용성 보장
- 수평 확장 및 축소 관리
- 스케줄링 담당
	- 컨테이너를 클러스터 안의 적절한 서버(Node)에 자동으로 배치하는 것을 의미
- 네트워크 설정 관리
- health 상태 모니터링
- 설정값 관리

### 2.1.2 데이터 센터 운영체제
쿠버네티스를 데이터 센터 운영체제 또는 클러스터 운영체제라고 다르게 표현할 수 있습니다. 데이터 센터(또는 클러스터)는 여러 서버를 연결해서 하나의 시스템처럼 동작하도록 구성된 시스템입니다. 운영체제는 CPU, 메모리와 같은 하드웨어 장치를 관리 및 제어하기 위한 소프트웨어입니다. 운영체제는 프로그램이 실행할 수 있도록 전반적인 환경을 제공합니다.

데이터 센터(클러스터)와 운영체제의 역할은 다음과 같습니다.
- **데이터 센터(클러스터)**
	- 여러 서버의 집합체
	- 컴퓨터 리소스의 군집
- **운영체제**
	- 프로세스 스케줄링
	- 컴퓨팅 자원 관리
	- 하드웨어 추상화
	- 사용자 인터페이스(UI) 제공

쿠버네티스를 데이터 센터 운영체제라고 정의하는 이유는 쿠버네티스가 **여러 서버들을 하나로 연결**하여 추상화한 뒤, 사용자가 이를 효율적으로 제어할 수 있도록 **인터페이스를 제공**하고, 컨테이너들이 정상적으로 실행되도록 다양한 기능 제공하는 플랫폼이기 때문입니다. 쿠버네티스는 일반 PC와 비교했을 때 더 이해하기 쉽습니다. 일반 PC는 하드웨어 장치를 직접 제어하지 않고 **운영체제(예: 리눅스)를 통해 컴퓨터를 제어하고 프로그램을 실행**합니다. 이와 같이 클러스터 시스템을 제어할 때는 쿠버네티스를 사용합니다.

![[image-31.png]]

## 2.2 쿠버네티스의 기본 개념
쿠버네티스는 운영체제와 유사한 방식으로 기능들을 제공합니다. 예를 들어, 사용자가 각각의 노드(서버)들을 직접 제어하지 않고 쿠버네티스를 통해서 클러스터를 제어할 수 있도록 하드웨어 추상화 기능을 제공하며, 컨테이너 스케줄링, 자원 할당 관리 등의 기능을 제공합니다. 또한, 일반 PC에서 사용자가 GUI를 통해서 컴퓨터를 쉽게 제어하듯이 쿠버네티스에서는 `kubectl`이라는 CUI를 통해서 쿠버네티스를 제어합니다. 비록 `kubectl`가 GUI는 아니여도 쿠버네티스를 제어하기에 충분히 강력합니다.

### 2.2.1 애완동물 vs 가축
쿠버네티스는 서버를 애완동물(Pet)보다는 **가축(cattle)**에 비유합니다. 서버는 가축에 비유하는 이유는 애완동물은 세심한 관리가 필요한 반면에 가축은 떼로 방목하며 키웁니다. 애완동물은 개체마다 정해진 이름이 있고, 배고프지 말라고 끼니를 챙겨주며, 아프지 말라고 예방접종을 합니다. 반면, 가축은 개별적으로 정해진 이름 없이 무리로 관리합니다. 그리고 무리에서 죽기도하는 개체가 나옵니다. 애완동물과는 다르게 가축 한 두마리 죽는것에 크게 슬퍼하지 않습니다. 쿠버네티스 도한 서버를 바라보는 관점이 애완동물보다는 가축에 가깝습니다.

첫째, 쿠버네티스는 서버마다 특별한 이름을 부여하지 않습니다. 이는 물리적인 서버마다 특정 역할이 정해져 있지 않다는 의미입니다. 예를 들어, 특정 서버의 역할을 빌드 서버, 웹 서버, 모니터링 서버 등으로 구분하지 않습니다.

둘째, 쿠버네티스는 가축처럼 한두 개의 서버가 다운되더라도 문제 없습니다. 왜냐하면 다운되지 않은 **다른 서버에게 해당 역할을 자동으로 맡길 수 있기 때문**입니다. 쿠버네티스에서는 **모든 서버들이 마스터 노드와 워커 노드로 구성**됩니다. 마스터 노드에는 쿠버네티스를 실행하기 위한 핵심 컴포넌트만 존재하고, 워커 노드에서는 단순히 컨테이너를 실행하기 위한 환경으로만 사용합니다. 워커들마다 특별한 역할을 맡지 않기 때문에 마스터 노드가 죽지 않는 이상 특정 워커 노드가 수행하던 역할을 다른 워커 노드가 맡아도 문제 없습니다. 이는 컨테이너가 고립된 환경에서 실행하기 때문에 가능한 일입니다. 이러한 특징 덕분에 쿠버네티스는 많은 서버를 관리하는데 수월합니다.

### 2.2.2 바라는 상태(Desired State)
쿠버네티스에는 "바라는 상태"라는 개념이 있습니다. "바라는 상태"는 에어컨 시스템에 비유 할 수 있습니다. 일반적으로 에어컨을 사용할 때, 에어컨에는 현재 온도가 있고 사용자가 원하는 희망 온도가 있습니다. 에이컨 시스템이 사용자의 희망온도에 맞추어 현재 온도를 변경시키기 위해서 에어컨 시스템을 작동하듯이, **쿠버네티스는 사용자의 요청에 따라서 현재 상태가 "바라는 상태"와 동일해지도록 사전에 미리 정의된 특정 작업을 수행**합니다. 쿠버네티스에는 **바라는 상태란 사용자가 원하는 최종 애플리케이션 배포 상태**를 말합니다. 사용자는 원하는 애플리케이션 배포 상태를 쿠버네티스에 알려주면 **쿠버네티스가 자동으로 현재 배포 상태를 사용자가 원하는 배포 상태로 변경**합니다."바라는 상태"의 장점은 클러스터의 특정 컨테이너에 장애가 발생하여 애플리케이션이 중단되어도 쿠버네티스는 "바라는 상태"를 알기 때문에 **원래의 배포 상태로 되살릴 수 있습니다.** 이것을 **"자가 치유"**라고 합니다.

### 2.2.3 컨트롤러(Controller)
사용자가 원하는 배포 상태(바라는 상태)를 선언하면, 쿠버네티스는 현재 배포 상태를 사용자가 원하는 배포 상태로 변경합니다. **현재 배포 상태를 원하는 배포 상태(바라는 상태)로 변경하는 주체를 "컨트롤러(Controller)"**라고 부릅니다. 컨트롤러는 `control-loop` 라는 루프를 돌며 특정 리소스를 지속적으로 모니터링하다가, 사용자가 정의한 리소스의 이벤트에 따라 사전에 정의된 작업을 수행합니다. 예를 들어, 뒤에서 살펴볼 Job이라는 리소스를 사용자가 생성(바라는 상태)하면 그에 맞는 배치(Batch) 작업 프로세스를 실행합니다. 

### 2.2.4 쿠버네티스 리소스(Resource)
쿠버네티스는 모든 것을 리소스(Resource)로 표현합니다. `Pod`, `ReplicaSet`, `Deployment` 등 쿠버네티스에는 다양한 리소스가 있고 각 리소스에는 고유의 역할이 있습니다. 각 리소스마다 세부적인 정의와 역할, 동작 방식이 다르지만 쿠버네티스에는 모두 리소스로 표현합니다. 코버네티스의 가장 기본적인 리소스는 `Pod`입니다. **`Pod`는 하나 이상의 컨테이너**를 가지는 **쿠버네티스의 최소 실행 단위**입니다. 쿠버네티스에서 컨테이너를 실행한다는 의미는 `Pod` 리소스를 생성하는 것과 동일합니다. (컨테이너와 Pod는 완벽하게 동일하지 않지만 Pod를 더 쉽게 이해하기 위한 설명)

### 2.2.5 선언형 커맨드(Declarative Command)
쿠버네티스는 **선언형 커맨드(Declarative Command)**를 지향합니다. 선언형 커맨드란 사용자가 직접 시스템 상태를 변경하지 않고 **쿠버네티스가 사용자가 원하는 배포 상태(바라는 상태)로 변경하도록 사용자가 선언적으로 지정하는 방법**입니다. 선형형 커맨드의 반대 개념은 **명령형(Imperative) 커맨드**입니다. 명령형 커맨드는 일반적으로 자주 사용하는 명령 형식입니다. 명령형 커맨드는 명령어를 어떻게 실행시킬지에 대한 방식이라면 선언형 커맨드는 무엇을 실행시킬지에 대한 방식입니다. 명령형 커맨드의 대표적인 예시로 SQL 쿼리가 있습니다. SQL 쿼리는 어떻게 테이블의 데이터를 조회할지에 대한 명령입니다. 대부분의 명령은 이러한 명령형 커맨드에 기반합니다. 반면 선언형 커맨드의 대표적인 예시로 HTML 문서가 있습니다. HTML 문서에는 명령어가 어떻게 수행해야 할지에 대한 정보가 없습니다. 대신 HTML 문서에는 무엇을 해야 하는지 선언되어 있습니다. 예를 들어, `<a href>`라는 태그가 선언되어 있으면, 웹 브라우저에서는 해당 선언(태그)을 보고 하이퍼링크를 연결해야 한다는 것(WHAT)을 알 수가 있기 때문에 웹 브라우저가 직접 하이퍼링크를 연결하는 작업을 수행합니다. 

쿠버네티스는 YAML 형식을 사용하여 선언형 커맨드를 지정합니다. 다음은 쿠버네티스에서 사용하는 YAML 형식의 `Pod` 예시입니다.
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - image: nginx
    name: nginx
```

### 2.2.6 네임스페이스(Namespace)
쿠버네티스에는 클러스터를 논리적으로 분리하는 **네임스페이스**라는 개념이 있습니다. 물리적인 하나의 쿠버네티스 클러스터 위에서 **네임스페이스라는 논리적 단위로 클러스터 환경을 나눌 수 있습니다.** 각 네임스페이스마다 서로 다른 권한을 설정할 수 있으며, 서로 다른 네트워크 정책도 설정할 수 있습니다. 쿠버네티스의 모든 리소스는 크게 **네임스페이스 레벨 리소스**와 **클러스터 레벨 리소스**로 구분됩니다. 

네임스페이스 리소스는 특정 네임스페이스 안에 속합니다. `Pod`, `Deployment`, `Service`와 같이 대부분의 쿠버네티스 리소스가 네임스페이스 안에 포함됩니다. 반면, `Node`, `PersistentVolume`, `StorageClass`와 같이 네임스페이스 영역에 상관없이 클러스터 레벨에서 존재하는 리소스도 있습니다. 네임스페이스는 사용자가 자유롭게 추가, 삭제가 가능합니다.

다음 그림을 보면 쿠버테니스 클러스터 안에 특정한 네임스페이스가 존재합니다. 해당 네임스페이스에 Service, Pod 들이 존재합니다. 이러한 Service, Pod 리소스들은 Namespace 안에 소속되어 있지만, Cluster Level Resource들인 PersistentVolume, Node, StorageClass는 특정 네임스페이스들에 소속되어 있지 않고 존재합니다.
![[image-32.png]]

### 2.2.7 라벨 & 셀렉터(Label & Selector)
쿠버네티스에는 독특한 리소스 질의 체계가 존재합니다. 특정 리소스(또는 리소스 그룹)에 명령을 전달하거나 정보를 조회하고 싶을 때 **라벨링 시스템**을 이용합니다. 라벨링 시스템을 이용하여 리소스를 질의하기 위해서 **먼저 리소스에 key-value 형식의 태그 정보(라벨)을 붙입니다.** 그리고 태그한 리소스를 찾기 위해 **셀렉터**를 이용하여 특정한 key-value를 가진 리소스만 추출합니다. 쿠버네티스는 리소스 간의 관계를 **느슨하게 연결(loosely coupled)**되는 구조를 가지기 때문에 **라벨 & 셀렉터 매커니즘**을 이용합니다.

예를 들어 리소스 A, B 두 그룹이 존재한다고 가정합니다. 리소스 두 그룹의 구성은 다음과 같습니다.
- 리소스 A : 다이아몬드, 하트, 스페이드
- 리소스 B : 클로버, 스페이드
리소스 A 그룹에는 다이아몬드, 하트, 스페이드 리소스가 존재하고 리소스 B 그룹에는 클로버, 스페이드 리소스가 존재합니다. 사용자는 모양(key)이 다이아몬드, 하트, 스페이드(value)인 라벨을 붙힙니다. 그리고 셀렉터에서 선택하고자 하는 라벨(모양)을 지정하여 리소스와 연결관계를 표현합니다.
예를 들어, 첫번째 셀렉터는 모양 라벨이 하트인 리소스만 질의하는 경우 리소스 A 그룹의 하트 리소스만 질의하게 됩니다. 두번째 셀렉터는 모양 라벨이 스페이드인 리소스만 질의하는 경우 리소스 A 그룹의 스페이드와 리소스 B 그룹의 스페이드를 둘다 질의하게 됩니다.
이와 같이 각각의 리소스에 key-value 형태의 라벨이라는 것을 붙인 다음에 셀렉터가 라벨에 따른 리소스를 질의하게 됩니다.

쿠버네티스는 특정한 라벨을 가진 리소스를 대상으로 작업을 수행할 수 있습니다. 예를 들어 쿠버네티스 Service는 특정한 라벨을 가진 Pod들을 자동으로 감지하여 트래픽을 분산할 수 있습니다. `selector: app=backend`가 설정된 Service는 해당 라벨(app=backend)이 적용된 모든 Pod를 자동으로 로드밸런싱합니다.

정리하면 쿠버네티스의 라벨 & 셀렉터 매커니즘을 이용하여 리소스를 효율적으로 분류하고 자동화할 수 있으며, 이를 통해 서비스 디스커버리, 스케일링, 보안 관리, 환경 분리 등이 훨씬 쉬워집니다.

### 2.2.8 서비스 탐색
쿠버네티스 클러스터 안에서 통신하기 위해서는 노드(서버) 위치와는 상관없이 어디든 접근할 수 있는 서비스 엔드포인트(Service Endpoint)가 필요합니다. 사용자 또는 Pod는 서비스 엔드포인트를 통해서 다른 컨테이너(Pod)와 통신할 수 있습니다. 다른 Pod와 통신하기 위해서는 서비스 엔드포인트의 접속 정보(예를 들어 IP)를 알아야 합니다. 이를 **서비스 탐색(Service Discovery)** 이라고 합니다.
쿠버테니스에서는 DNS 기반의 서비스를 지원하기 때문에 사용자가 매번 새로운 서비스의 IP 주소를 탐색하지 않고 도메인 주소를 기반으로 서비스에 접근하면 됩니다. **쿠버네티스에서는 서비스 탐색 기능을 Service 리소스를 이용하여 제공하고 있습니다.**

### 2.2.9 설정 관리
쿠버네티스에서는 컨테이너 실행시 필요한 **설정값과 시크릿 정보(credentials)** 를 쿠버네티스 플랫폼에서 관리할 수 있는 매커니즘을 제공합니다. 이러한 기능 덕분에 사용자는 서버마다 필요한 설정값을 저장하거나, 서버 간의 설정값 동기화 문제를 직접 해결할 필요 없이 쿠버테니스 클러스터에서 제공하는 **설정값 관리 기능**을 활용 할 수 있습니다.
즉, 정리하면 각 컨테이너마다 설정값을 저장할 필요 없이 쿠버테니스에서 설정값을 관리 할 수 있도록 지원할 수 있습니다.
쿠버네티스에서는 **`ConfigMap` 또는 `Secret`이라는 리소스**를 이용하여 컨테이너의 설정들을 관리합니다.

## 2.3 아키텍처
쿠버네티스는 클러스터 시스템과 비슷하게 마스터와 워커 노드로 구분됩니다.
![[image-33.png]]
### 2.3.1 마스터
마스터 노드의 핵심 컴포넌트는 다음과 같습니다.
- kube-apiserver : 마스터로 들어오는 모든 요청을 받는 REST API 서버
- etcd : 클러스터 안에 모든 메타 정보를 저장하는 저장소
- kube-scheduler : 컨테이너를 워커 노드에 할당하는 스케줄러
- kube-controller-manager : 현재 배포 상태와 사용자가 원하는 배포 상태(바라는 상태)를 지속적으로 확인하며 특정 이벤트(예: 컨테이너 다운)에 따라 특정 동작(예: 컨테이너 재시작)을 수행하는 컨트롤러
- cloud-controller-manager : 클라우드 플랫폼(AWS, GCP, Azure 등)에 특화된 리소스를 제어하는 클라우드 컨트롤러
	- 예를 들어 AWS 환경에서 실행되는 CCM으로 AWS의 EC2, ELB, EBS 등을 쿠버네티스에서 자동 관리할 수 있도록 지원합니다.

마스터 노드는 단일 서버로 구성될 수 있고, 고가용성을 위해 마스터 노드 역할을 하는 여러 서버를 묶어서 클러스터 마스터로도 구축할 수 있습니다.

#### kube-apiserver(API 서버)
- api 서버는 클라이언트의 요청을 받는 역할을 하는것 뿐만 아니라 직접 다른 컴포넌트에게 요청을 보내는 역할도 수행합니다. 
- 사용자도 `kubectl`을 이용하여 api 서버에 명령을 보내고 응답 받습니다. 
- 마스터 노드와 통신한다는 의미는 이 api 서버와 통신한다는 것을 의미합니다.

#### etcd(저장소)
- 쿠버네티스 클러스터에 필요한 **모든 메타 데이터 정보를 저장하는 저장소 역할**을 수행합니다.
- 데이터는 key-value 형태로 저장합니다.
- 고가용성을 위해서 여러개의 etcd 저장소를 etcd 클러스터로 구축해서 안정성을 높힐 수 있습니다.

#### kube-scheduler(컨테이너 스케줄러)
- 해당 컴포넌트는 아직 실행되지 못한 컨테이너가 없는지 확인하고 쿠버네티스 위에 새로운 컨테이너를 실행할 때 워커 노드 상태, 요청 리소스량, 제약 조건에 따라서 적절한 서버를 선택해서 컨테이너를 할당하는 역할을 담당합니다.
- 정리하면 kube-scheduler는 클러스터의 컨테이너 스케줄링을 수행합니다.

#### kube-controller-manager(컨트롤러 집합)
- 해당 컴포넌트는 클러스터의 현재 배포 상태와 사용자가 원하는 배포 상태(바라는 상태)를 비교해서 현재 배포 상태를 원하는 배포 상태로 변경하도록 수행합니다.
- 쿠버네티스에는 리소스(Service, Pod 등) 별로 개별적인 리소스 컨트롤러가 존재합니다.
- 개별적인 리소스 컨트롤러들을 하나의 컴포넌트로 합친것을 kube-controller-manager입니다.

#### cloud-controller-manager(클라우드 컨트롤러)
- 쿠버네티스 리소스를 이용해서 클라우드 플랫폼(AWS, GCP, Azure 등)의 로드 밸런스를 연결하거나 스토리지를 추가할 수 있습니다.
- 클라우드 플랫폼에 특화된 리소스를 제어하기 위해서 쿠버네티스 마스터 노드에는 따로 cloud-controller-manager라는 컴포넌트를 가지고 있습니다.

### 2.3.2 노드
워커 노드의 구성은 다음과 같습니다.
- kubelet : 마스터 노드의 명령에 따라 컨테이너의 라이프 사이클을 관리하는 노드 관리자
- kube-proxy : 컨테이너의 네트워킹을 책임지는 프록시
- container runtime : 실제 컨테이너를 실행하는 컨테이너 실행 환경

#### kubelet(노드 관리자)
- 마스터 노드로부터 특정 컨테이너를 실행시키기 위해 상세 스펙(spec)를 받아 실행시키고, 해당 컨테이너가 정상 동작하는지 지속적으로 모니터링 수행합니다.
- 주기적으로 api 서버와 통신하며 마스터 노드와 워커 노드간에 필요한 정보를 서로 주고받습니다.(노드 상태 정보, 리소스 사용량 등)

#### kube-proxy(네트워크 프록시)
- kube-proxy는 각 워커 노드에 위치하며 클라이언트의 요청이 Service를 통해 적절한 Pod로 라우팅 되도록 네트워크 규칙을 관리합니다.
- 서비스마다 개별 IP를 가질 수 있게 만들어 주고 클러스내 내/외부의 트래픽을 Pod로 전달할 수 있도록 패킷을 라우팅합니다.

#### container runtime(컨테이너 실행 환경)
- 실제 컨테이너 실행시키는 역할을 담당합니다.
- 대표적인 예시로 도커 프로세스가 있습니다.

## 2.4 쿠버네티스의 장점
### 2.4.1 실행 환경 고립화
- 여러대의 서버에서 실행 환경 상관없이 컨테이너를 실행 시킬 수 있습니다.

### 2.4.2 리소스 관리
- 쿠버네티스는 여러 서버의 리소스를 체계적으로 관리하는 기능을 제공합니다.
- 예를 들어 서벼별 리소스 사용량 모니터링, 리소스 사용량 제한하는 등 클러스터 시스템이 전반적인 리소스를 관리할 수 있습니다.

### 2.4.3 스케줄링
- 새로운 프로세스 실행시 서버의 개수가 많으면 어떤 서버가 현재 가용 가능한지, 어떤 서버에 메모리가 충분한지 등을 일일이 확인하기 쉽지 않습니다.
- 쿠버네티스의 스케줄링 기능을 활용하면 사용자가 직접 확인할 필요 없이 적절한 워커 노드를 찾은 다음에 컨테이너를 배치합니다.

### 2.4.4 프로세스 관리
- 사용자가 직접 서버별로 실행중인 프로세스, 완료된 프로세스 또는 에러가 발생한 프로세스를 지속적으로 모니터링하기 쉽지 않습니다.
- 사용자는 쿠버네티스 클러스터 내에서 실행중인 모든 컨테이너를 명령어 하나로 확인할 수 있습니다.
- 사용자는 마스터 노드의 api서버에 요청하면 해당하는 프로세스를 쉽게 확인할 수 있습니다.

### 2.4.5 통합 설정 관리
- 각각의 여러 서버에서 설정값을 파일로 보관하는 대신에 중앙 저장소에서 통합하여 설정값으로 관리할 수 있습니다.
- 통합 설정 관리를 통해서 종속성 없이 어느 서버에서나 프로세스를 정상적으로 실행할 수 있습니다.
	- 종속성의 사례로는 애플리케이션이 특정 환경 변수(DB_HOST, API_KEY 등)에 의존하지만, 서버마다 환경 변수가 다르게 실행이 되는 경우가 있습니다. 
	- 기존에는 서버별로 그에 맞는 특정 환경 변수를 파일로 해당 서버에 저장해야 했지만, 쿠버네티스의 통합 설정 관리를 이용하면 환경 변수 값을 통합적으로 관리할 수 있습니다.

### 2.4.6 장애 대응
- 종종 하나의 프로세스가 장애가 발생하는 경우 서버 전체에 장애로 번지는 경우가 있습니다. 대표적인 사례로 프로세스가 메모리 관리를 잘못해서 서버 전체 메모리를 고갈시키는 경우가 있습니다.
- 쿠버네티스는 프로세스마다 **리소스 사용량을 제한**해서 같은 서버에서 동작하는 다른 프로세스에 영향을 미치지 않도록 할 수 있습니다.
- 이번에는 서버 자체에 장애가 발생해서 서버에서 실행중인 컨테이너 전부에게 문제가 발생할 수 있습니다. 이러한 경우 쿠버네티스는 **다른 서버로 교체**할 수 있습니다.

### 2.4.7 자동 확장
- 쿠버네티스는 프로비저닝한 리소스가 부족하여 새로운 리소스가 필요한 경우 자동 추가해서 운영 비용을 최소하하고 안정성을 높힐 수 있습니다.

### 2.4.8 하이브리드 클라우드 운영
- 쿠버네티스는 클라우드와 온프레미스, 혹은 멀티 클라우드 환경에서 동일한 서비스를 제공할 수 있습니다.

### 2.4.9 자가 치유
- 컨테이너가 다운되어도 컨테이너를 다시 자동 실행시켜서 사용자가 원하는 배포 상태(바라는 상태)로 유지시킵니다.

### 2.4.10 데이터 스토리지 관리
- 쿠버네티스 이용시 다양한 데이터 저장소를 자동으로 관리해줍니다.
- 가장 기본적으로는 로컬 스토리지가 될 수 있으며, 클라우드 플랫폼에서 제공하는 저장소(AWS S3 등)나 NFS와 같이 네트워크 스토리지를 쉽게 연결하고 해제할 수 있는 기능을 제공합니다.

### 2.4.11 배포 자동화
- 사용자가 원하는 배포 상태(바라는 상태)를 선언하면 쿠버네티스가 자동으로 적절한 노드를 선택해서 컨테이너를 배치합니다.
- 새로운 버전의 애플리케이션을 배포하는 경우에 기존 버전의 애플리케이션을 중지하고 새로운 버전의 애플리케이션을 배포하는 것과 같은 롤링 업데이트 기능을 지원합니다.

## 2.5 마치며
- 쿠버네시트에 대한 전반적인 **개념과 아키텍처, 장점**에 대해서 살펴보았습니다.























