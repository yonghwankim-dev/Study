
- [[#Redis|Redis]]
- [[#Memcached|Memcached]]
- [[#Hazelcast|Hazelcast]]
- [[#Apache Ignite|Apache Ignite]]
- [[#Couchbase|Couchbase]]
- [[#Global Cache 비교|Global Cache 비교]]



### Redis
- 특징
	- 인메모리 저장소
		- 모든 데이터를 메모리에 저장하기 때문에 빠른 성능(마이크로초 단위의 응답속도)을 제공합니다.
		- 디스크 기반 데이터베이스보다 빠르지만, 메모리 용량에 의존된다
	- 다양한 데이터 구조 지원
		- String, Hash, List, Set, Sorted Set과 같은 데이터 구조를 지원합니다.
	- 데이터 영속성 지원
		- RDB 또는 AOF 방식의 백업 기능을 제공합니다.
		- RDB(Snapshotting) : 일정 주기마다 데이터를 디스크에 저장합니다.
		- AOF(Append-Only File) : 모든 변경 사항을 로그 파일에 기록하여 장애 발생 시 복구 가능합니다.
	- 분산 및 확장성 지원
		- Redis Sentinel과 Redis Cluster 서비스 기능을 제공합니다.
		- Redis Sentinel 기능은 고가용성 보장을 위한 장애 감지 및 자동 복구하는 기능입니다.
		- Redis Cluster 기능은 여러 노드로 데이터를 샤딩(Sharding)하여 확장성을 제공합니다.
	- 고급 기능 지원
		- Pub/Sub 기능 지원 : 메시지 브로커 기능 제공
		- Lua 스크립트 지원 : 서버엥서 실행 가능한 스크립팅 기능
		- 트랜잭션 지원 : MULTI 명령어를 사용하여 일괄 실행 기능

- 장점
	- 빠른 성능
		- 모든 데이터를 메모리에 저장하기 때문에 읽기/쓰기 성능이 빠릅니다.
		- 데이터베이스나 디스크 기반 캐시보다 낮은 지연율
	- 다양한 데이터 구조 지원
		- 단순 key-value가 아니라 List, Set, Sorted Set 등의 구조를 지원
	- 확장성과 고가용성
		- Redis Sentinel을 활용하여 자동 장애 감지 복구를 지원합니다.
		- Redis Cluster를 이용한 수평 확장 기능을 지원합니다.
	- 데이터 영속성 지원
		- RDB, AOF 옵션을 통해 영속성 보장
- 단점
	- 메모리 의존성
		- 모든 데이터를 메모리에 저장하므로 RAM 용량이 한정적입니다.
		- 데이터 크기가 클 경우 비용 부담이 증가됩니다.
	- 복잡한 데이터 쿼리 지원 부족
		- SQL을 지원하지 않으며, 복잡한 조건 검색(Join, Group By 등)이 어렵습니다.
		- 단순 key-value 조회에는 적합하지만, 관계형 데이터 모델링은 부적합합니다.
	- 데이터 일관성 문제
		- 기본적으로 Eventually Consistent 방식이기 때문에 일관성이 즉시 보장되지 않습니다.
		- AOF 방식에서도 일부 데이터 손실 가능성이 존재합니다.
	- 높은 운영 비용
		- 클러스터 운영시 샤딩 및 장애 감지 설정이 필요합니다.
		- 대량의 데이터를 저장하려면 RAM 비용이 증가합니다.

### Memcached
- 특징
	- key-value 기반 분산 메모리 캐시 시스템
	- 단순한 구조
	- 멀티 스레드 지원 (Redis 보다 동시 처리 성능이 우수함)
- 장점
	- 빠른 성능
		- 다중 쓰레드를 지원하기 때문에 높은 처리량이 가능함
	- 단순한 구조
	- 수평 확장성 우수
		- 클러스터링을 쉽게 구성 가능함
- 단점
	- 데이터 영속성 없음
		- 서버가 재시작되면 캐시 데이터가 소멸됨
	- 데이터 일관성 보장이 어려움
		- 분산 환경에서 최신 데이터 유지가 어려움
	- 고급 기능 부족
		- Redis 처럼 Lua 스크립트, Pub/Sub, TTL 관리 기능이 없음

### Hazelcast
- 특징
	- 인메모리 데이터 그리드 기반의 분산 캐시
	- 클러스터링을 통해서 노드 간 데이터 공유 가능
	- Spring과 통합이 쉬움 (Spring Boot Starter 제공)
- 장점
	- 분산 환경에서 높은 확장성
		- 노드 추가만으로 확장 가능
	- 캐시 외 다양한 기능 제공
		- Map, Queue, Pub/Sub, SQL 쿼리 지원
	- Spring과의 강력한 통합
		- Spring Cache, Hibernate 2차 캐시 지원
- 단점
	- 메모리 사용량이 크다
		- 대용량 데이터 처리 시 리소스 소비가 크다
	- Redis 대비 성능 다소 낮음
		- 캐시 성능은 Redis 보다 다소 떨어짐
	- 네트워크 오버헤드
		- 노드간 데이터 복제시 네트워크 비용이 발생함

### Apache Ignite
- 특징
	- 인메모리 데이터 그리드(IMDG)로 동작하는 분산 캐시
	- SQL 쿼리 지원(RDBMS처럼 사용 가능)
	- Spring Data 통합 지원
- 장점
	- 캐시 + 데이터 저장소 역할 가능
		- 메모리와 디스크 저장 가능
	- SQL 지원
		- 관계형 데이터베이스처럼 사용할 수 있음
	- Spring 통합에 용이함
		- Hibernate 2차 캐시, Spring Data와 쉽게 연동 가능
- 단점
	- 구성 및 관리 복잡
		- 클러스터 설정 및 튜닝 필요
	- 초기 학습 곡선이 높음
		- 기능이 많아서 설정이 어려울 수 있음
	- 네트워크 오버 헤드
		- 노드 간 데이터 복제 시 비용이 발생함
### Couchbase
- 특징
	- NoSQL 기반의 분산 key-value 캐시 및 데이터 저장소
	- 강력한 쿼리 기능(SQL++ 지원)
	- JSON 기반 데이터 저장 가능함
- 장점
	- 캐시 + NoSQL 기능 제공
		- 단순 캐시 외에도 영구 저장 기능
	- 수평 확장 용이
		- 다중 노드 클러스터링 지원
	- TTL 관리 기능
		- 자동 캐시 만료 설정 기능
- 단점
	- Redis보다 성능 다소 낮음
		- 캐시 성능은 Redis보다 떨어질 수 있음
	- 운영 복잡도 증가
		- DB 기능이 있어서 단순 캐시로 사용하기에는 다소 부담

### Global Cache 비교

| 특징        | Redis                                  | Memcached                     | Hazelcast                         | Apache Ignite                 | Couchbase                         |
| --------- | -------------------------------------- | ----------------------------- | --------------------------------- | ----------------------------- | --------------------------------- |
| 데이터 저장 방식 | 인메모리(옵션에 따라서 디스크 저장 가능)                | 인메모리(디스크 저장 불가능)              | 인메모리(디스크 저장 가능)                   | 인메모리 + 디스크 영속성                | 인메모리 + 디스크 영속성                    |
| 데이터 구조    | key-value, List, Set, Sorted Set, Hash | 단순 key-value                  | key-value, Map, Queue, MultiMap   | key-value, SQL, ACID 트랜잭션 지원  | JSON 문서 기반(key-value 및 쿼리 지원)     |
| 데이터 영속성   | RDB(스냅샷), AOF(Append-Only Log) 지원      | 미지원                           | 지원(MapStore를 활용한 DB 연동 가능)        | 완전한 영속성 지원(DB처럼 사용 가능)        | 완전한 영속성 지원(NoSQL DB역할 가능)         |
| 확장성       | Redis Cluster로 샤딩 가능                   | 여러 서버로 분산 가능(서버 간 데이터 공유 불가)  | 네이티브 분산 캐시 지원(서버간 자동 동기화)         | 자동 샤딩 및 클러스터 확장 지원            | 자동 샤딩 및 클러스터 확장 지원                |
| 고가용성      | Redis Sentinel 지원(자동 장애 감지 및 복구)       | 클러스터링 필요(자동 복구 기능 없음)         | 분산 클러스터로 데이터 복제 가능                | 고가용성 및 자동 복구 지원               | 고가용성 및 자동 복구 지원                   |
| 트랜잭션 지원   | MULTI/EXEC 명령어로 지원                     | 지원하지 않음                       | 지원(Atomic Operation)              | 완전한 ACID 트랜잭션 지원              | ACID 트랜잭션 일부 지원                   |
| 쿼리 지원     | 단순 key-value 조회, Lua 스크립트 가능           | 단순 key-value 조회               | key 기반 조회                         | SQL 기반 쿼리 가능                  | SQL 및 N1QL(SQL-Like) 지원           |
| 사용사례      | 캐싱, 세션 저장, 실시간 데이터 처리, 메시지 큐           | 단순 캐싱(예: 웹서버 세션 저장)           | Java 애플리케이션 내장 캐시, 분산 데이터 저장      | SQL 지원 인메모리 DB, 고성능 데이터 처리    | 문서 기반 NoSQL DB, JSON 저장, 웹 애플리케이션 |
| 장점        | 빠른 속도, 다양한 자료구조, 영속성 지원                | 메모리 효율적 사용, 단순한 구조로 높은 성능     | Java 환경에서 사용 용이, 분산 데이터 자동 관리     | RDBMS와 유사한 SQL 지원, ACID 보장    | 문서형 저장소 SQL-Like 쿼리 지원            |
| 단점        | 메모리 사용량이 많음, 관계형 쿼리 지원 부족              | 데이터 영속성 없음, 다중 서버간 데이터 공유 불가능 | Java에 종속적, 대규모 트래픽 처리시 성능 이유가 가능함 | 설정이 복잡함, 메모리와 디스크간 성능 최적화 필요함 | 설정이 복잡함, RDB보다 트랜잭션 성능이 낮음        |
