# 2진수의 음수 표현
## 목차
- [x] 소개
- [x] 부호 및 크기 방식
- [x] 1의 보수
- [x] 2의 보수
- [ ] 2의 보수로 변환
- [ ] 2의 보수 산술 연산

## 소개
이진수에서 음수를 표현하는데 몇가지 방법이 있다. 

십진수에서는 십진수 앞에 -(마이너스)부호를 붙여서 음수로 표현할 수 있다. 그러나 이진수에서는 0또는 1로 구성되어 있기 때문에 이렇게 할 수 없다.

먼저 음수를 나타내는 두가지 초기 구현과 그 단점을 알아보고 2의 보수에 대해서 설명합니다.

## 부호 및 크키 방식
부호 크기로 양수/음수를 나타내기 위하여 가장 왼쪽에 있는 bit하나를 지정합니다. 

0은 양수, 1은 음수로 나타냅니다.
- 1000011 = -3
- 0000011 = 3

### 음수를 이진법으로 나타내는 것의 부작용
bit 하나를 부호 비트로 사용하게 되면 표현할 수 있는 숫자가 절반으로 줄어든다. 이유는 음수까지 표현해야하기 때문이다.

예를 들어 부호 비트없이 8bit로 표현할 수 있는 숫자는 다음과 같다.
- 0~255 (00000000 ~ 11111111)
- 전체 256개의 숫자를 표현할 수 있음

부호 비트를 사용하고 8bit로 표현할 수 있는 숫자는 다음과 같다.
- 11111111 : -127
- 10000000 : 0
- 00000000 : 0
- 01111111 : 127
- 전체 255개의 숫자를 표현할 수 있음

## 1의 보수
1의 보수는 부호 크기에서 다음 단계입니다. 부호 크기와 비슷하게 가장 중요한 비트는 숫자의 부호를 나타낸다. 그러나 음수의 경우에는

**일반적인 비트에서 비트를 반전(1을 0으로 0을 1로)시킨다.** 

일반적인 부호 크기 방식
- 00000100 : 4
- 100000100 : -4

1의 보수 방식
- 00000100 : 4
- 11111011 : -4

1의 보수에서도 여전히 0과 -0을 가집니다. 그러나 부호 없는 이진수와 매우 비슷한 방식으로 기본 산술을 할 수 있다는 장점이 있다.

## 2의 보수
가장 왼쪽에 있는 비트가 일반적으로 나타내는 값의 음수라고 말하는 것입니다.

일반 부호 없는 이진법을 사용하면 4bit는 0~15를 표현할 수 있습니다.

![](images/img_7.png)

8대신 가장 왼쪽에 있는 비트가 -8을 나타내도록 하면 4bit로 -8 ~ 7을 표현할 수 있다.

![](images/img_8.png)

- 1000 : -8 = -2^3
- 1001 : -7 = -2^3 + 1
- 1010 : -6 = ...
- 1011 : -3
- 1100 : -4
- 1101 : -3
- 1110 : -2
- 1111 : -1
- 0000 : 0
- 0001 : 1
- 0010 : 2
- 0011 : 3
- 0100 : 4
- 0101 : 5
- 0110 : 6
- 0111 : 7

## 2의 보수로 변환
2의 보수로 변환하는 방법은 다음과 같습니다.
1. 십진수에서 이진수로 변환
2. 이진수의 비트 앞에 0을 붙여줍니다.
   - 예를 들어 3의 이진수가 11이면 011이 됩니다.
3. 이진수에서 1의 보수로 변환
4. 1의 보수인 상태에서 +1을 더함

예를 들어 십진수 3을 -3으로 변환하는 방법은 다음과 같습니다.
1. 십진수 3을 가집니다. => 3
2. 십진수 3을 부호 없이 이진수 11로 변환합니다. => 11
3. 비트들의 개수가 요구하는 패딩비트를 붙여줍니다. => 011
4. 비트를 반전시킴 => 100
5. 반전시킨 비트에 1을 더함 => 101

검산하면 101을 음수로 표현하면 -1*2^2 + 1*2^0 = -4 + 1 = -3이므로 십진수 -3을 이진수로 표현하면 101이 됩니다.

4단계와 5단계를 자세히 살펴보겠습니다.

4단계에서 하는 일은 매우 흥미롭습니다. 만약 우리가 가장 왼쪽의 비트를 무시한다면, 다른 숫자들을 반점시킴으로써 우리는 원래의 숫자에서

많은 비트들로 가능한 최대치를 형성할 수 있는 양수를 만들 수 있습니다. 예를 들어 다음과 같습니다.

- 3bit로 만들수 있는 최대값은 7입니다. (111)
- 만약 십진수 2를 가진다면 이진수로 010을 가질 것입니다. (패딩된 상태)
- 010을 반전시킨다면 101이 나옵니다. 이는 십진수로 5를 나타냅니다.
- 5 + 2 = 7

만약 5에서 7을 뺀다면 -2을 얻을 것입니다. 그러나 우리는 항상 최대 숫자보다 1 더 큰 숫자를 사용할 것입니다. 

(이진법에서 왼쪽의 다음 숫자는 항상 이전의 모든 비트의 최댓값보다 1 더큰 값을 나타냅니다.)

예를 들어 십진수 7은 이진수로 111이고 이진수에서 1 더큰값은 1000으로써 십진수로 표현하면 8이 됩니다.

가장 왼쪽에 있는 비트는 음수이므로 여기서 일반적으로 8이 아니라 -8입니다.(움의 1은 처음 3비트 중 최댓값인 7보다 큼).

비트를 반점시킴으로써 이 값을 1로 설정합니다. 이는 5 - 8 = -3을 의미합니다. 그런 다음 1을 추가하여 -2가 되게 합니다.

십진수 => 2
이진수 => 010
반전 => 101 -> 십진수 5
+1 => 110 => -4 + 2 = -2 => 십진수 -2

## 2의 보수 산술 연산
2의 보수를 이용하여 덧셈 뺄셈을 어떻게 하는지 알아봅니다. 기본적으로 부호없는 이진수 더하기와 동일하지만 마지막 단계에서 변화가 있습니다.

주의해야할 몇가지 시나리오가 있습니다.
- 초기 숫자보다 1비트 큰 결과 생성은 폐기됩니다.
- 만약 두 양수를 더했을때 가장 왼쪽에 있는 비트가 1이면 오버플로입니다.
- 만약 두 음수를 더했을때 가장 왼쪽에 있는 비트가 0이면 오버플로입니다.

예를 들어 -66 + 69 = 10111110 + 01000101 = 1(버림수)00000011 = 3

왜 가장 왼쪽에 있는 비트를 버리는가?

2의 보수에서 우리는 가장 왼쪽 비트를 보면 부호를 알 수 있습니다. 0이면 양수, 1이면 음수입니다. 

두개의 양수를 더하면 결과가 양수일 것이라고 예상합니다. 그런데 가장 왼쪽에 있는 결과가 1이면 음수이게 되므로 모순이 발생합니다.

따라서 이는 오버플로가 발생하여 정해진 비트에서 숫자를 표현할 수 없는 것입니다.

이는 음수에서도 마찬가지입니다. 




## References
- [Binary Negative Numbers!](https://ryanstutorials.net/binary-tutorial/binary-negative-numbers.php#arithmetic)


