
### 아키텍처(Architecture)는 무엇인가?
  
 **아키텍처는 전체적인 시스템 개발을 위해서 초기에 결정하는 변경 불가능한 집합**입니다. 아키텍처는 사용법(usage)에 대한 설명입니다. Java, Eclipse, Spring, Tomcat, Hibernate, MySQL, MVC와 같은 기술은 툴이나 프레임워크이지 아키텍처가 아닙니다.
 아키텍처에 대한 예시로 예배당을 비유할 수 있습니다. 예배당 아키텍처의 설계도를 보면 설계도의 가운데에 제대(祭臺)라는 것이 존재합니다. 제대의 역할은 기독교 예배에서 제물이나 성찬을 올리는 역할을 수행합니다. 그리고 제대의 좌우에는 촛대가 존재하고 앞에는 신자들이 기도할 수 있도록 앉는 의자들이 존재합니다. 그리고 제대의 반대편에는 신자들이 오갈 수 있는 출입문이 존재할 것입니다. 예배당 설계도를 보면 제대나 의자, 출입문과 같은 구성 요소들이 잘 반영되어 있을 것입니다.
 
 ![[Pasted image 20250630143904.png]]

그래서 예배당 설계도를 본 사람들은 그 구조를 보고성당이라고 판단 할 수 있습니다. 이처럼 설계도에 나타난 구조와 요소들의 배치는 특정한 용도와 목적을 암시합니다. 이러한 요소 간의 배치와 역할, 그리고 그것들이 어떻게 사용되는지를 표현한 것이 바로 아키텍처입니다. 
따라서 아키텍처를 정의하자면, **설계도에 담긴 구성 요소들의 사용 방식과 상호 작용을 설명하는 체계**라고 할 수 있습니다.
아키텍처는 단순히 어떤 툴, 프레임워크 또는 재료를 선택하는 문제가 아니라, 그것들이 **어떻게 사용되고 서로 연동되는가(Usage)** 에 대한 고민이 중심이 되어야 합니다.

### 유스케이스(UseCase)란 무엇인가?
시스템에서 사용법(Usage)을 표현하기 위해서 유스케이스가 사용되어야 합니다. 
유스케이스란 액터(Actor, 시스템 사용자)와 시스템 사이에서 상호작용하여 기능의 목적을 이루는 단계를 의미합니다.
예를 들어 "게시글 작성하기"라는 유스케이스가 존재하는 경우 다음과 같은 단계로 수행될 수 있습니다.
1. 사용자가 제목을 입력한다.
2. 시스템이 제목의 유효성을 조사한다.
3. 사용자가 본문을 입력한다.
4. 시스템이 본문의 유효성을 조사합니다.
5. 사용자가 글 작성하기를 요청합니다.
6. 시스템이 글을 저장합니다.

### 아키텍처는 사용법(Usage)를 노출시킨다
아키텍처는 위에서 말한것처럼 어떠한 구체적인 내용들인 Hibernate를 사용했다던가, MyBatis를 사용했다든지 같은 상세한 내용들을 작성하는 것이 아닙니다. 예배당으로 비유를 하면 설계도에 제대를 보여주는 것이 아닌 제대를 어떤 재료로 만들었는지를 보여주고 있습니다. 이러한 설계도는 아키텍처의 의도를 벗어난 설계도입니다.

다음 그림은 ATM 현금 인출기의 아키텍처입니다. 
ATM Processor 모듈이 존재하고 해당 모듈은 카드 읽기(CardReader) 기능을 사용하고 현금을 받는 예금 슬롯(DepositSlot) 기능을 사용합니다. 그리고 데이터를 저장하기 위해서 Database 모듈을 사용하고 패널 기능을 제공하기 위해서 Front Pannel 기능을 사용합니다. Front Pannel은 기능을 제공하기 위해서 Display 기능과 Keyboard 기능을 사용하고 있습니다.

다음 그림을 보면 ATM Processor는 CardReader, DepositSlot, Database, Front Pannel에 의존하고 있습니다. 다음 그림을 보면 모듈이 어느 방향으로 의존하고 있는지 파악할 수 있습니다. 반대로 화살표를 받는 모듈 같은 경우에는 의존받는지 모릅니다. 예를 들어 ATM Processor는 CardReader를 의존하고 있지만 CardReader는 자신이 의존받는지 모릅니다.

![[Pasted image 20250630152338.png]]

그런데 만약에 위 아키텍처에 Spring, MySQL, MyBatis과 같은 상세한 내용들이 들어가면 적절하지 않은 아키텍처가 됩니다.
적절하지 않은 아키텍처 사례로 MVC 구조만 있는 웹 시스템이 있습니다. 이러한 시스템에서는 UseCase를 숨기고 Delivering 수행방식만 노출시킵니다. 중요한 것은 Delivering 수행 방식을 노출시키는 것이 아닌 UseCase를 노출시켜야 합니다. 노출 시킨 **UseCase는 Delivering 수행 방식과 결합되지 않아야(Decoupling)** 합니다. 그리고 Delivering 수행 방식만이 아닌 UI, DB, Framework, Tools 등을 대상으로도 UseCase와는 완전히 결합되지 않아야 합니다.

### 지연되는 결정(Deferring Decisions)
**좋은 아키텍처는 Framework, WAS, UI 등과 같은 상세한 내용의 결정을 연기(deferment)해야 합니다.** 아키텍처 설계시 우리는 모르는 것을 모르는(Unknown Unknowns) 경우가 많습니다. 모르는 것을 알게되는 경우는 자기가 생각한 시스템을 직접 사용했을 때입니다. 그래서 직접 사용할때까지는 사용자가 무언가 변경을 요구했을 때 우리가 수용할 수 있게 나머지 부분을 유연하게 갈 필요가 있습니다.
만약에 아키텍처 설계를 시작하면서 MySQL, MyBatis, Hibernate와 같은 것들을 미리 정하고 시작하게 된다면 사용자가 요구사항 변경을 요구했을 때 수용하기가 어렵거나 시간이 많이 걸리게 됩니다.

아키텍처의 핵심을 이루는 도메인 로직이 UseCase로만 이루어진다면 웹, 안드로이드, DB와 같은 요소들은 Application 로직에 해당되기 때문에 분리되어 있어야 합니다. 왜냐하면 Application 로직에 해당되는 요소들은 빈번하게 변경이 발생하기 때문입니다. 그래서 Application 로직에 해당되는 요소들은 미리 결정하지 않는 것이 좋습니다.

### Deferring Decisions의 예시: Fitness
우리는 Fitness라는 애플리케이션을 구현할 생각입니다. 구현하기 전 아키텍처를 작성하기 위해서 다음과 같은 적절하지 생각을 할 수 있습니다.
- 위키 데이터 저장을 위해서 데이터베이스로 MySQL 언어를 생각합니다.
- 무언가를 하기 전에 데이터베이스를 먼저 가동하고 스키마를 개발해야 한다고 생각합니다.

위와 같은 생각은 적절하지 않습니다. 왜냐하면 Fitness 아키텍처 설계시 위와 같은 생각들은 바로 필요한 것들이 아니기 때문입니다. 중요한 점은 **위키 텍스트를 html로 변환하는 것에 초점을 맞추는 것**입니다. 왜냐하면 **파싱(Parsing), 번역하는 코드는 데이터베이스 없이도 개발 할 수 있기 때문**입니다.

중요한 것은 WikiPage라는 중요한 추상화를 가지는 것입니다. WikiPage의 특징 및 기능은 다음과 같습니다.
- wiki 텍스트를 가집니다.
- toHtml: wiki 텍스트를 html로 파싱합니다.
- save: wiki 텍스트 데이터를 데이터베이스에 저장합니다.

![[Pasted image 20250630161300.png]]

WikiPage 인터페이스라는 인터페이스가 존재하고 구현체 클래스로 MockWikiPage가 있습니다. 해당 구현체의 save 메서드는 아무것도 하지 않고 그저 재정의만 수행합니다. 왜냐하면 아직 데이터베이스는 필요없기 때문입니다. 그런데 클라이언트 입장에서는 WikiPage 인터페이스를 통하여 save 메서드를 호출하면 작동해야 합니다. 이 문제를 해결하기 위해서 구현체로 MockWikiPage를 구현한 다음에 save 메서드를 재정의합니다. 물론 이 메서드는 아무것도 하지 않습니다. 이렇게 하면 개발자는 WikiPage의 toHtml 메서드 구현에 집중할 수 있습니다.

위와 같이 DB없이 설계 및 구현한 다음에 시간이 지나서 하나 이상의 페이지를 사용해야 하는 경우가 발생할 수 있습니다. 이러한 경우 데이터베이스가 실제로 필요한 상황이 됩니다. 하지만 우리는 정말로 데이터베이스가 필요한지 생각해볼 수 있습니다. 이 문제를 해결하기 위해서 다음과 같이 WikiPage 인터페이스의 새로운 구현체 클래스인 InMemoryPage를 설계할 수 있습니다. 해당 구현체는 페이지 데이터를 메모리에 임시적으로 저장하는 기능을 수행합니다.

![[Pasted image 20250630162859.png]]

InMemoryPage를 보면 내부 저장소 타입으로 HashTable을 사용하고 있습니다. 키값으로 아이디를 사용하고, value 값으로 위키페이지 자체를 저장합니다.
위와 같이 데이터베이스를 사용하지 않고 인메모리를 사용한다면 충분히 여러 페이지를 오가면서 구현할 수 있습니다.

위와 같이 인메모리 페이지를 도입하며 toHtml 메서드 구현에만 집중함으로써 다음과 같은 일이 발생했습니다.
- MySQL을 사용하지 않게 되었습니다.
- 실제 데이터베이스를 사용하지 않음으로써 주요한 아키텍처 결정을 연기할 수 있었습니다.
- 고객의 요구사항 변경으로 모든 데이터는 실제 데이터베이스에 넣어야 한다는 정책으로 인하여 MySqlPage 구현체를 만들고 넣도록 하였습니다.

### 핵심적인 추상화(Central Abstraction)
많은 아키텍처는 데이터베이스를 아주 핵심적인 추상화라고 생각합니다. 데이터베이스가 동작하고 스키마가 준비되기 전에는 어떠한 생각도, 작업도 시작하지 않는 경향을 가지고 있습니다.
다음 그림을 보면 중앙에 데이터베이스가 존재하고 Tasks, Models, Commands 등과 같은 모듈들이 전부 데이터베이스에 의존하고 있는 것을 볼수 있습니다. 이러한 구조는 데이터베이스의 스키마가 변경시 데이터베이스를 의존하고 있는 다른 모듈들에 영향을 미칠 가능성이 있습니다. 또한 데이터베이스 스키마에 맞추어 모듈들의 구조가 정해져 버리는 현상이 생길 수 있습니다.
![[Pasted image 20250630165755.png]]

애플리케이션 개발자 입장에서 제일 중요한 것은 데이터베이스 또는 데이터가 아닌 행동(behavior)입니다. Fitness 프로젝트의 핵심적인 추상화는 데이터베이스가 아닌 WikiPage입니다.
해당 프로젝트에서는 데이터베이스를 연기할 수 있는 상세한 것(Detail)로 간주하고 최대한 결정을 미룹니다. 또한 Tool, Framework, UI, WAS 등과 같은 상세한 것들도 최대한 결정을 미루도록 합니다.
이렇게 상세한 요소들에 대해서 아키텍처에서 최대한 결정을 미루기 위해서는 **아키텍처 측면에서 소프트웨어 환경이 아닌 UseCase에 집중**해야 합니다.

### 결론
- 아키텍처를 설계시 UseCase에 집중하세요. 
- UseCase에 집중하고 UI, Framework, WAS, DB 등과 같은 상세한 것들에 대해서는 최대한 결정을 미루세요.
- 아키텍처를 UseCase에 집중하여 구현하게 되면 프로젝트를 진행하면서 충분한 정보가 생성됨에 따라서 되돌리는 비용 없이 여러번 변경할 수 있게 됩니다.

