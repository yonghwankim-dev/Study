# 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

## 상속을 고려한 설계와 문서화
상속용 클래스는 **재정의할 수 있는 메서드**들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야한다.
- 어떤 순서로 호출 되는지
- 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지

다음은 java.util.AbstractCollection에서 발췌한 예이다.
```text
public boolean remove(Object o)

주어진 원소가 이 컬렉션 안에 있다면 그 인스턴스를 하나 제거한다(선택적 동작). 더 정확하게 말하면,
이 컬렉션 안에 'Object.equals(o, e)가 참인 원소'e가 하나 이상 있다면 그 중 하나를 제거한다.
주어진 원소가 컬렉션 안에 있었다면(즉, 호출 결과 이 컬렉션이 변경됐다면) ture를 반환한다.

Implementation Requirements: 이 메서드는 컬렉션을 순회하며 주어진 원소를 찾도록 구현되었다.
주어진 원소를 찾으면 반복자의 remove 메서드를 사용해 컬렉션에서 제거한다. 이 컬렉션이 주어진
객체를 갖고 있으나, 이 컬렉션의 iterator 메서드가 반환한 반복자가 remove 메서드를 구현하지
않았다면 UnsupportedOperationException을 던지니 주의하자.
```

위 Implementation Requirements에 따르면 iterator 메서드를 재정의하면 remove 메서드의 동작에

영향을 준다는 것을 알 수 있습니다.

따라서 **클래스를 안전하게 상혹할 수 있도록 하려면 내부 구현 방식을 설명해야만 한다.**


## 효율적인 하위 클래스를 어려움 없이 만들수 있게 하려면 어떻게 해야 하는가
클래스의 내부 동작 과정 주간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공해야 할 수도 있다.

